from collections.abc import Iterator
from itertools import islice
from typing import Protocol, Self

from randcrack import RandCrack


class IntegerRNG[StateT](Protocol):
    """Integer random number generator protocol."""

    def __iter__(self) -> Iterator[int]:
        """Return the iterator."""
        return self

    def __next__(self) -> int:
        """Return the next value."""
        raise NotImplementedError

    def state(self) -> StateT:
        """Return the inner state."""
        raise NotImplementedError

    @staticmethod
    def from_state(state: StateT) -> Self:
        """Set the inner state."""
        raise NotImplementedError


MersenneTwisterState = tuple[list[int], int]
RandCrackerState = tuple[list[int], int]


class MersenneTwister(IntegerRNG[MersenneTwisterState]):
    """Mersenne Twister 19937 PRNG."""

    N = 624
    M = 397
    W = 32
    R = 31
    UMASK = 0xFFFFFFFF << R
    LMASK = 0xFFFFFFFF >> (W - R)
    A = 0x9908B0DF
    U = 11
    S = 7
    T = 15
    L = 18
    B = 0x9D2C5680
    C = 0xEFC60000
    F = 1812433253
    MODULO = 2**32

    state_array: list[int]
    predict_array: list[int]
    predict: bool
    state_index: int

    def __init__(self, seed: int):
        """Create a new Mersenne Twister 19937 PRNG from given seed."""
        assert 0 <= seed < 2**32, "Seed must be between 0 and 2^32"

        self.state_index = 0
        self.state_array = [seed] + [0] * (self.N - 1)
        self.predict_array = []
        self.predict = False

        for i in range(1, self.N):
            seed = self.F * (seed ^ (seed >> (self.W - 2))) % self.MODULO + i
            self.state_array[i] = seed

    def __next__(self) -> int:
        """Return the next value."""
        if not self.predict:
            k = self.state_index
            j = k - (self.N - 1)
            if j < 0:
                j += self.N

            x = (self.state_array[k] & self.UMASK) | (self.state_array[j] & self.LMASK)
            x_a = x >> 1
            if x & 1:  # modulo 2 == 1
                x_a ^= self.A

            j = k - (self.N - self.M)
            if j < 0:
                j += self.N

            x = self.state_array[j] ^ x_a
            self.state_array[k] = x
            k += 1
            if k >= self.N:
                k = 0
            self.state_index = k

            y = x ^ (x >> self.U)
            y ^= (y << self.S) & self.B
            y ^= (y << self.T) & self.C
            y ^= y >> self.L
            return y & 0xFFFFFFFF  # Ensure 32-bit output4

        predictor = RandCrack()
        predictor.mt = self.predict_array
        predictor.state = True
        predictor.counter = self.state_index
        result = predictor.predict_getrandbits(32)
        self.state_index += 1
        return result

    def state(self) -> MersenneTwisterState | RandCrackerState:
        """Return the inner state."""
        if not self.predict:
            return self.state_array.copy(), self.state_index
        return self.predict_array.copy(), self.state_index

    @staticmethod
    def from_state(state: RandCrackerState) -> "MersenneTwister":
        """Set the inner state."""
        rng = MersenneTwister(0)
        rng.predict_array, rng.state_index = state[0].copy(), state[1]
        rng.predict = True
        return rng

def reverse_mersenne(mersenne: "MersenneTwister") -> RandCrackerState:
    """Find state by Randcrack algorihtm and return its state and iterator."""
    # There are numbers generated by generator
    battery = list(islice(mersenne, 624)) # This will be raplaced by numbers from txt

    predictor = RandCrack()

    assert len(battery) > 623, "Battery have less than 624 numbers!"

    for i in range(624):
        predictor.submit(battery[i])

    rand_state: RandCrackerState = (predictor.mt, predictor.counter)

    return rand_state


if __name__ == "__main__":
    orig = MersenneTwister(159753478)
    pred_state = reverse_mersenne(orig)

    pred: MersenneTwister = orig.from_state(pred_state)

    print(f"Predicted: {pred.__next__()}")
    print(f"Original: {orig.__next__()}")
